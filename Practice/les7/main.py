
# MAP

# some_list = [1, 2, 3, 4, 5]
# for ind in range(len(some_list)):
#     some_list[ind] = str(some_list[ind])
# print(some_list)

# new_list = list(map(str, some_list))
# print(new_list)

# # ^^^ Эта запись аналогична записи выше, в map мы можем заложить любую функцию, которую map применит ко всем обьектам списка
# # map - это цикл

# def square(x):
#     return x ** 2

# sqr_list = list(map(square, some_list))

# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# FILTER

# some_list = [1, 2, 3, 4, 5]
# def even(x):
#     return x % 2 == 0

# new_list = list(filter(even, some_list))
# print(new_list)

# Функция filter берет функцию и записывает в новый список только те элементы, которые имеют результат проверки true

# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# LAMBDA

# some_list = [1, 2, 3, 4, 5]

# new_list = list(filter(lambda x: type(x) == int, some_list))
# print(new_list)

# Сокрашенная запись функций

# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# ENUMERATE

# some_list = [10, 20, 30, 40]
# for ind, value in enumerate(some_list):
#     print(ind, value)

# print(enumerate(list((some_list))))

# Создает кортежи данных

# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# ZIP 
# Обьединяет не списки с индексами, а список со списком, кортеж с кортеджем

# first_list = ['apple', 'orange', 'grape']
# second_list = ['яблоко', 'апельсин', 'виноград']

# for eng, ru in zip(first_list, second_list):
#     print(eng, ru)


# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# 47. У вас есть код, который вы не можете менять(так часто бывает, когда код в глубине программы используется множество раз и вы не хотите ничего сломать):
# transformation = <???>
# values = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # или любой другой список
# transormed_values = list(map(transformation, values))
# Единственный способ вашего взаимодействия с этим кодом - посредством задания функции transformation.
# Однако вы поняли, что для вашей текущей задачи вам не нужно никак преобразовывать список значений, а нужно получить его как есть.
# Напишите такое лямбда-выражение transformation, чтобы transformed_values получился копией values

# values = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

# transformation = lambda x: x

# transformed_values = list(map(transformation, values))
# print(transformed_values)

# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# 49. Планеты вращаются вокруг звезд по эллиптическим орбитам. Назовем самой далекой планетой ту, орбита которой имеет самую большую площадь. 
# Напишите функцию find_farthest_orbit(list_of_orbits), которая среди списка орбит планет найдет ту, по которой вращается самая далекая планета. 
# Круговые орбиты не учитывайте: вы знаете, что у вашей звезды таких планет нет, зато искусственные спутники были были запущены на круговые орбиты. 
# Результатом функции должен быть кортеж, содержащий длины полуосей эллипса орбиты самой далекой планеты. Каждая орбита представляет из себя кортеж 
# из пары чисел - полуосей ее эллипса. Площадь эллипса вычисляется по формуле S = piab, где a и b - длины полуосей эллипса. 
# При решении задачи используйте списочные выражения. Подсказка: проще всего будет найти эллипс в два шага: сначала вычислить самую большую площадь 
# эллипса, а затем найти и сам эллипс, имеющий такую площадь. Гарантируется, что самая далекая планета ровно одна


# import math
# def find_farthest_orbit(orbits):
#     max = 0
#     imax = 0
#     for i in range(len(orbits)):
#         S = math.pi*orbits[i][0]*orbits[i][1]
#         if orbits[i][0] != orbits[i][1]:
#             if S > max:
#                 max = S
#                 imax = i
#     return orbits[imax]

# # Ввод:
# orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)]
# print(*find_farthest_orbit(orbits))
# # Вывод:
# # 2.5 10

# import math
# orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)]
# print(list(filter(lambda x: x[0] != x[1], orbits))) 
# # Отфильтровали круглые орбиты

# new = list(filter(lambda x: x[0] != x[1], orbits))
# new2 = max(map(lambda x: x[0] * x[1] * math.pi, new))
# print(list(filter(lambda x: x[0] * x[1] * math.pi == new2, new)))

# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Массив с числами, проверить есть ли в массиве два числа, сумма которых равна целевому значению

# some_list = [1, 23, 4, 2, 5, 64, 12, 55, 21, 23, 45, 21, 14]
# celivoe = 7

# def sum_cel(list):
#     for i in some_list:
#         for j in range(1, len(some_list)):
#             if i + some_list[j] == celivoe:
#                 print(f'{i} + {some_list[j]} = {celivoe}') 
#                 break
            
# for el in some_list:
#     if celivoe - el in some_list:
#         print('yes')
#         break

# cet_list = set(some_list)
# for el in some_list:
#     if celivoe - el in cet_list:
#         print('yes')
#         break
#  Более быстрое решение для данной задачи, так как set (множество) пробигается моментально

# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Напишите функцию same_by(characteristic, objects), которая проверяет, все ли объекты имеют одинаковое значение некоторой характеристики, и 
# возвращают True, если это так. Если значение характеристики для разных объектов отличается - то False. 
# Для пустого набора объектов, функция должна возвращать True. Аргумент characteristic - это функция, которая принимает объект и вычисляет его характеристику.

def same_by(characteristics, objects):
    if len(objects) == 0:
        return True
    for i in range(len(objects)):
        if characteristics(objects[i]) != characteristics(objects[0]):
            return False
    return True

# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------




